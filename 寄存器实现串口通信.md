

#### 1、使用HAL库点亮led

(1)创建新项目

![在这里插入图片描述](https://img-blog.csdnimg.cn/99644f89204e4b188e05c7b1102cff0c.png)


（2）选择自己的芯片，点击startproject即可

![在这里插入图片描述](https://img-blog.csdnimg.cn/c2ac5a7811c5471d9c77fa17601049ae.png)


（3）点击system core，进入SYS，在debug下选择serial wire： 
![在这里插入图片描述](https://img-blog.csdnimg.cn/bd6e19a80caf49c38cdb09f5c78df11a.png)


（4）配置时钟，进入上面的rcc，有两个时钟，一个是hse和lse，我们要用是GPIO接口，而这些接口都在APB2里： 

![在这里插入图片描述](https://img-blog.csdnimg.cn/42e60ab241fa4e16a85596a89807f5b5.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/817d1e5425ba4a07a7b5400a7ccb623d.png)

（5）将hse那里设为Crystal/Ceramic Resonator： 

![在这里插入图片描述](https://img-blog.csdnimg.cn/c1252eba31f84cbd92535e0618543d14.png)


（6）接下来就是点击相应的引脚设置输出寄存器了，就是output那一项，一共选了三个，是PA4，PB9，PC15：  
![在这里插入图片描述](https://img-blog.csdnimg.cn/a9d46e6f0771419098a38fefedf07963.png)



（7）点击project manager，配置好自己的路径和项目名，然后IDE那项改为MDK-ARM： 

![在这里插入图片描述](https://img-blog.csdnimg.cn/4784e4b330cf489c836a593db71a21dd.png)


（8）进入 code generate界面，选择生成初始化.c/.h文件，后面点击generate code，选择open project，然后就到KEIL5了： 
![在这里插入图片描述](https://img-blog.csdnimg.cn/af0fc5afb3ba45159b567e1e75754cf9.png)



#### 2、使用keil生成.hex文件

（9）打开项目中生成的.uvprojx文件进入keil

![在这里插入图片描述](https://img-blog.csdnimg.cn/a34e91e61e2343f7851a875f496215be.png)

（10）keil中编译并运行生成.hex文件

点击图中的魔棒工具

![在这里插入图片描述](https://img-blog.csdnimg.cn/2f95597549a840bb9ae8a66a76065fee.png)

进入output，勾选生成.hex文件

![在这里插入图片描述](https://img-blog.csdnimg.cn/bb7e8b06f8cc41f49670b89dce3d4af5.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/ce7c48c7ff454e2ba4f881308915f744.png)

#### 3、运行单片机是灯泡闪烁

（1）使用到的工具：stm32c8t6单片机、面包板、数根公线母线、usb转ttl接口、三个不同颜色的灯泡

usb转ttl接口和stm32连接如下图所示：

![img](https://img-blog.csdnimg.cn/daf3711c457f4c01b8ab91f0243e3cd2.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6bmk5byV,size_20,color_FFFFFF,t_70,g_se,x_16) 

整个线路板接法如下图所示：

![img](https://img-blog.csdnimg.cn/daf3711c457f4c01b8ab91f0243e3cd2.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6bmk5byV,size_20,color_FFFFFF,t_70,g_se,x_16)

（2）将usb接口接入电脑，查看是否连接成功

![在这里插入图片描述](https://img-blog.csdnimg.cn/3427fdfb5a02450fb7a4adeda66fd449.png)
在这里插入图片描述


（3）打开mcuisp开始烧录并运行
![在这里插入图片描述](https://img-blog.csdnimg.cn/6da41b73c1c04616a91edc916e3e35a1.png)



按照图中顺序进行操作，得到运行画面

![在这里插入图片描述](https://img-blog.csdnimg.cn/fd999b1e3cfc4161af74b407220f0933.gif)

如果按照上述步骤没有成功，大部分原因是因为线路接法的问题，一定检查线路是否接错。还有可能就是boot的问题，一开始进行烧录要将boot0置于1，boot1置为0去写入程序。后将boot0置为0,boot1置为0就可以进行运行了。

4、keil中仿真观看输出波形图

（1）Target界面中，选择跟正确的晶振大小，我使用的是8MHz的外部晶振。这个选项在软件仿真中起到很重要的作用，如果选择错误，那么波形一定是错误的，因为时间不准确。

![img](https://img-blog.csdnimg.cn/abbb7e5429ac4a68b44f5b542ee40497.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAV09PWkk5NjAwTMKy,size_20,color_FFFFFF,t_70,g_se,x_16) 

（2）Debug页的设置：

![img](https://img-blog.csdnimg.cn/e7348524d6424c3a9dc86f8d9e28da9b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAV09PWkk5NjAwTMKy,size_20,color_FFFFFF,t_70,g_se,x_16) 

（3）点击Debug，进入调试界面：

![img](https://img-blog.csdnimg.cn/82bb8f4ba5c845b2884f0c85dcc6232f.png) 

（4）选择逻辑分析仪：

![img](https://img-blog.csdnimg.cn/7014b0178ad748f6839f149e10e67f3f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAV09PWkk5NjAwTMKy,size_20,color_FFFFFF,t_70,g_se,x_16) 



（5）选择要观察的引脚：
①点击Setup Logic Analyzer

![img](https://img-blog.csdnimg.cn/00e03e73917844af92ad4796e454e714.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAV09PWkk5NjAwTMKy,size_20,color_FFFFFF,t_70,g_se,x_16) 

②添加要观察的引脚：

![在这里插入图片描述](https://img-blog.csdnimg.cn/15bd145d45984ce88906a21b47afdad8.png)


（6）相关设置

![img](https://img-blog.csdnimg.cn/7950965d6d324c2e87de3aebca8f6ff4.png) 

（7）运行程序：

![在这里插入图片描述](https://img-blog.csdnimg.cn/3bf4f4347c2341eba52cc0dafd9e6c21.png)

8）观察波形：

![1666442955023](C:\Users\HP\AppData\Local\Temp\1666442955023.png)

### 2、寄存器实现串口通信

创建sam.s的汇编文件，插入代码:

```
;RCC寄存器地址映像             
RCC_BASE            EQU    0x40021000 
RCC_CR              EQU    (RCC_BASE + 0x00) 
RCC_CFGR            EQU    (RCC_BASE + 0x04) 
RCC_CIR             EQU    (RCC_BASE + 0x08) 
RCC_APB2RSTR        EQU    (RCC_BASE + 0x0C) 
RCC_APB1RSTR        EQU    (RCC_BASE + 0x10) 
RCC_AHBENR          EQU    (RCC_BASE + 0x14) 
RCC_APB2ENR         EQU    (RCC_BASE + 0x18) 
RCC_APB1ENR         EQU    (RCC_BASE + 0x1C) 
RCC_BDCR            EQU    (RCC_BASE + 0x20) 
RCC_CSR             EQU    (RCC_BASE + 0x24) 
                              
;AFIO寄存器地址映像            
AFIO_BASE           EQU    0x40010000 
AFIO_EVCR           EQU    (AFIO_BASE + 0x00) 
AFIO_MAPR           EQU    (AFIO_BASE + 0x04) 
AFIO_EXTICR1        EQU    (AFIO_BASE + 0x08) 
AFIO_EXTICR2        EQU    (AFIO_BASE + 0x0C) 
AFIO_EXTICR3        EQU    (AFIO_BASE + 0x10) 
AFIO_EXTICR4        EQU    (AFIO_BASE + 0x14) 
                                                           
;GPIOA寄存器地址映像              
GPIOA_BASE          EQU    0x40010800 
GPIOA_CRL           EQU    (GPIOA_BASE + 0x00) 
GPIOA_CRH           EQU    (GPIOA_BASE + 0x04) 
GPIOA_IDR           EQU    (GPIOA_BASE + 0x08) 
GPIOA_ODR           EQU    (GPIOA_BASE + 0x0C) 
GPIOA_BSRR          EQU    (GPIOA_BASE + 0x10) 
GPIOA_BRR           EQU    (GPIOA_BASE + 0x14) 
GPIOA_LCKR          EQU    (GPIOA_BASE + 0x18) 
                                                       
;GPIO C口控制                   
GPIOC_BASE          EQU    0x40011000 
GPIOC_CRL           EQU    (GPIOC_BASE + 0x00) 
GPIOC_CRH           EQU    (GPIOC_BASE + 0x04) 
GPIOC_IDR           EQU    (GPIOC_BASE + 0x08) 
GPIOC_ODR           EQU    (GPIOC_BASE + 0x0C) 
GPIOC_BSRR          EQU    (GPIOC_BASE + 0x10) 
GPIOC_BRR           EQU    (GPIOC_BASE + 0x14) 
GPIOC_LCKR          EQU    (GPIOC_BASE + 0x18) 
                                                           
;串口1控制                       
USART1_BASE         EQU    0x40013800 
USART1_SR           EQU    (USART1_BASE + 0x00) 
USART1_DR           EQU    (USART1_BASE + 0x04) 
USART1_BRR          EQU    (USART1_BASE + 0x08) 
USART1_CR1          EQU    (USART1_BASE + 0x0c) 
USART1_CR2          EQU    (USART1_BASE + 0x10) 
USART1_CR3          EQU    (USART1_BASE + 0x14) 
USART1_GTPR         EQU    (USART1_BASE + 0x18) 
                            
;NVIC寄存器地址                
NVIC_BASE           EQU    0xE000E000 
NVIC_SETEN          EQU    (NVIC_BASE + 0x0010)     
;SETENA寄存器阵列的起始地址 
NVIC_IRQPRI         EQU    (NVIC_BASE + 0x0400)     
;中断优先级寄存器阵列的起始地址 
NVIC_VECTTBL        EQU    (NVIC_BASE + 0x0D08)     
;向量表偏移寄存器的地址     
NVIC_AIRCR          EQU    (NVIC_BASE + 0x0D0C)     
;应用程序中断及复位控制寄存器的地址                                                
SETENA0             EQU    0xE000E100 
SETENA1             EQU    0xE000E104 
                            
                              
;SysTick寄存器地址            
SysTick_BASE        EQU    0xE000E010 
SYSTICKCSR          EQU    (SysTick_BASE + 0x00) 
SYSTICKRVR          EQU    (SysTick_BASE + 0x04) 
                              
;FLASH缓冲寄存器地址映像     
FLASH_ACR           EQU    0x40022000 
                             
;SCB_BASE           EQU    (SCS_BASE + 0x0D00) 
                             
MSP_TOP             EQU    0x20005000               
;主堆栈起始值                
PSP_TOP             EQU    0x20004E00               
;进程堆栈起始值             
                            
BitAlias_BASE       EQU    0x22000000               
;位带别名区起始地址         
Flag1               EQU    0x20000200 
b_flas              EQU    (BitAlias_BASE + (0x200*32) + (0*4))               
;位地址 
b_05s               EQU    (BitAlias_BASE + (0x200*32) + (1*4))               
;位地址 
DlyI                EQU    0x20000204 
DlyJ                EQU    0x20000208 
DlyK                EQU    0x2000020C 
SysTim              EQU    0x20000210 


;常数定义 
Bit0                EQU    0x00000001 
Bit1                EQU    0x00000002 
Bit2                EQU    0x00000004 
Bit3                EQU    0x00000008 
Bit4                EQU    0x00000010 
Bit5                EQU    0x00000020 
Bit6                EQU    0x00000040 
Bit7                EQU    0x00000080 
Bit8                EQU    0x00000100 
Bit9                EQU    0x00000200 
Bit10               EQU    0x00000400 
Bit11               EQU    0x00000800 
Bit12               EQU    0x00001000 
Bit13               EQU    0x00002000 
Bit14               EQU    0x00004000 
Bit15               EQU    0x00008000 
Bit16               EQU    0x00010000 
Bit17               EQU    0x00020000 
Bit18               EQU    0x00040000 
Bit19               EQU    0x00080000 
Bit20               EQU    0x00100000 
Bit21               EQU    0x00200000 
Bit22               EQU    0x00400000 
Bit23               EQU    0x00800000 
Bit24               EQU    0x01000000 
Bit25               EQU    0x02000000 
Bit26               EQU    0x04000000 
Bit27               EQU    0x08000000 
Bit28               EQU    0x10000000 
Bit29               EQU    0x20000000 
Bit30               EQU    0x40000000 
Bit31               EQU    0x80000000 


;向量表 
    AREA RESET, DATA, READONLY 
    DCD    MSP_TOP            ;初始化主堆栈 
    DCD    Start              ;复位向量 
    DCD    NMI_Handler        ;NMI Handler 
    DCD    HardFault_Handler  ;Hard Fault Handler 
    DCD    0                   
    DCD    0 
    DCD    0 
    DCD    0 
    DCD    0 
    DCD    0 
    DCD    0 
    DCD    0 
    DCD    0 
    DCD    0 
    DCD    0 
    DCD    SysTick_Handler    ;SysTick Handler 
    SPACE  20                 ;预留空间20字节 








                 
;代码段 
    AREA |.text|, CODE, READONLY 
    ;主程序开始 
    ENTRY                            
    ;指示程序从这里开始执行 
Start 
    ;时钟系统设置 
    ldr    r0, =RCC_CR 
    ldr    r1, [r0] 
    orr    r1, #Bit16 
    str    r1, [r0] 
    ;开启外部晶振使能  
    ;启动外部8M晶振 
                                            
ClkOk           
    ldr    r1, [r0] 
    ands   r1, #Bit17 
    beq    ClkOk 
    ;等待外部晶振就绪 
    ldr    r1,[r0] 
    orr    r1,#Bit17 
    str    r1,[r0] 
    ;FLASH缓冲器 
    ldr    r0, =FLASH_ACR 
    mov    r1, #0x00000032 
    str    r1, [r0] 
            
    ;设置PLL锁相环倍率为7,HSE输入不分频 
    ldr    r0, =RCC_CFGR 
    ldr    r1, [r0] 
    orr    r1, #(Bit18 :OR: Bit19 :OR: Bit20 :OR: Bit16 :OR: Bit14) 
    orr    r1, #Bit10 
    str    r1, [r0] 
    ;启动PLL锁相环 
    ldr    r0, =RCC_CR 
    ldr    r1, [r0] 
    orr    r1, #Bit24 
    str    r1, [r0] 
PllOk 
    ldr    r1, [r0] 
    ands   r1, #Bit25 
    beq    PllOk 
    ;选择PLL时钟作为系统时钟 
    ldr    r0, =RCC_CFGR 
    ldr    r1, [r0] 
    orr    r1, #(Bit18 :OR: Bit19 :OR: Bit20 :OR: Bit16 :OR: Bit14) 
    orr    r1, #Bit10 
    orr    r1, #Bit1 
    str    r1, [r0] 
    ;其它RCC相关设置 
    ldr    r0, =RCC_APB2ENR 
    mov    r1, #(Bit14 :OR: Bit4 :OR: Bit2) 
    str    r1, [r0]      


    ;IO端口设置 
    ldr    r0, =GPIOC_CRL 
    ldr    r1, [r0] 
    orr    r1, #(Bit28 :OR: Bit29)          
    ;PC.7输出模式,最大速度50MHz  
    and    r1, #(~Bit30 & ~Bit31)   
    ;PC.7通用推挽输出模式 
    str    r1, [r0] 
            
    ;PA9串口0发射脚 
    ldr    r0, =GPIOA_CRH 
    ldr    r1, [r0] 
    orr    r1, #(Bit4 :OR: Bit5)          
    ;PA.9输出模式,最大速度50MHz  
    orr    r1, #Bit7 
    and    r1, #~Bit6 
    ;10：复用功能推挽输出模式 
    str    r1, [r0]    


    ldr    r0, =USART1_BRR   
    mov    r1, #0x271 
    str    r1, [r0] 
    ;配置波特率-> 115200 
                   
    ldr    r0, =USART1_CR1   
    mov    r1, #0x200c 
    str    r1, [r0] 
    ;USART模块总使能 发送与接收使能 
    ;71 02 00 00   2c 20 00 00 
             
    ;AFIO 参数设置             
    ;Systick 参数设置 
    ldr    r0, =SYSTICKRVR           
    ;Systick装初值 
    mov    r1, #9000 
    str    r1, [r0] 
    ldr    r0, =SYSTICKCSR           
    ;设定,启动Systick 
    mov    r1, #0x03 
    str    r1, [r0] 
            
    ;NVIC                     
    ;ldr   r0, =SETENA0 
    ;mov   r1, 0x00800000 
    ;str   r1, [r0] 
    ;ldr   r0, =SETENA1 
    ;mov   r1, #0x00000100 
    ;str   r1, [r0] 
              
    ;切换成用户级线程序模式 
    ldr    r0, =PSP_TOP                   
    ;初始化线程堆栈 
    msr    psp, r0 
    mov    r0, #3 
    msr    control, r0 
              
    ;初始化SRAM寄存器 
    mov    r1, #0 
    ldr    r0, =Flag1 
    str    r1, [r0] 
    ldr    r0, =DlyI 
    str    r1, [r0] 
    ldr    r0, =DlyJ 
    str    r1, [r0] 
    ldr    r0, =DlyK 
    str    r1, [r0] 
    ldr    r0, =SysTim 
    str    r1, [r0] 
               
;主循环            
main            
    ldr    r0, =Flag1 
    ldr    r1, [r0] 
    tst    r1, #Bit1                 
    ;SysTick产生0.5s,置位bit 1 
    beq    main                  ;0.5s标志还没有置位       
     
    ;0.5s标志已经置位 
    ldr    r0, =b_05s                
    ;位带操作清零0.5s标志 
    mov    r1, #0 
    str    r1, [r0] 
    bl     LedFlas 


    mov    r0, #'H' 
    bl     send_a_char
	
	mov    r0, #'e' 
    bl     send_a_char
	
	mov    r0, #'l' 
    bl     send_a_char
	
	mov    r0, #'l' 
    bl     send_a_char
	
	mov    r0, #'o' 
    bl     send_a_char
	
	mov    r0, #' ' 
    bl     send_a_char
	
	mov    r0, #'w' 
    bl     send_a_char
	
	mov    r0, #'o' 
    bl     send_a_char
	
	mov    r0, #'r' 
    bl     send_a_char
	
	mov    r0, #'l' 
    bl     send_a_char
	
	mov    r0, #'d' 
    bl     send_a_char
	
	mov    r0, #'\n' 
    bl     send_a_char
	
	b      main
            
              
            
;子程序 串口1发送一个字符 
send_a_char 
    push   {r0 - r3} 
    ldr    r2, =USART1_DR   
    str    r0, [r2] 
b1 
    ldr    r2, =USART1_SR  
    ldr    r2, [r2] 
    tst    r2, #0x40 
    beq    b1 
    ;发送完成(Transmission complete)等待 
    pop    {r0 - r3} 
    bx     lr 


                 
;子程序 led闪烁 
LedFlas      
    push   {r0 - r3} 
    ldr    r0, =Flag1 
    ldr    r1, [r0] 
    tst    r1, #Bit0 
    ;bit0 闪烁标志位 
    beq    ONLED        ;为0 打开led灯 
    ;为1 关闭led灯 
    ldr    r0, =b_flas 
    mov    r1, #0 
    str    r1, [r0] 
    ;闪烁标志位置为0,下一状态为打开灯 
    ;PC.7输出0 
    ldr    r0, =GPIOC_BRR 
    ldr    r1, [r0] 
    orr    r1, #Bit7 
    str    r1, [r0] 
    b      LedEx 
ONLED       
    ;为0 打开led灯 
    ldr    r0, =b_flas 
    mov    r1, #1 
    str    r1, [r0] 
    ;闪烁标志位置为1,下一状态为关闭灯 
    ;PC.7输出1 
    ldr    r0, =GPIOC_BSRR 
    ldr    r1, [r0] 
    orr    r1, #Bit7 
    str    r1, [r0] 
LedEx        
    pop    {r0 - r3} 
    bx     lr 
                                
;异常程序 
NMI_Handler 
    bx     lr 


HardFault_Handler 
    bx     lr 
              
SysTick_Handler 
    ldr    r0, =SysTim 
    ldr    r1, [r0] 
    add    r1, #1 
    str    r1, [r0] 
    cmp    r1, #500 
    bcc    TickExit 
    mov    r1, #0 
    str    r1, [r0] 
    ldr    r0, =b_05s  
    ;大于等于500次 清零时钟滴答计数器 设置0.5s标志位 
    ;位带操作置1 
    mov    r1, #1 
    str    r1, [r0] 
TickExit    
    bx     lr 
                                                                           
    ALIGN            
    ;通过用零或空指令NOP填充,来使当前位置与一个指定的边界对齐 
    END

```

创建结构如图所示：

![1666441578538](C:\Users\HP\AppData\Local\Temp\1666441578538.png)

配置魔棒工具，如下图：

![1666441605449](C:\Users\HP\AppData\Local\Temp\1666441605449.png)

编译：

![1666441624995](C:\Users\HP\AppData\Local\Temp\1666441624995.png)



串口连接如下：

```
使用usb转ttl进行下载，具体连接如下
RXD->A2
TXD->A3
3.3V->3.3V
GND->GND
在使用是要将boot0置为0，boot1置为1
```

![1666441931764](C:\Users\HP\AppData\Local\Temp\1666441931764.png)



![1666441818780](C:\Users\HP\AppData\Local\Temp\1666441818780.png)

观察到输出，说明下载成功

打开野火串口调试助手观察输出：

打开串口:

![1666442066641](C:\Users\HP\AppData\Local\Temp\1666442066641.png)

就可以观察到数据的输出：

![1666442104775](C:\Users\HP\AppData\Local\Temp\1666442104775.png)

### 3、使用HAL库进行串口通信

1、创建项目![1666442248892](C:\Users\HP\AppData\Local\Temp\1666442248892.png)

2、选择芯片![1666442303737](C:\Users\HP\AppData\Local\Temp\1666442303737.png)

3、配置相关设置

![1666442379084](C:\Users\HP\AppData\Local\Temp\1666442379084.png)

![1666442405159](C:\Users\HP\AppData\Local\Temp\1666442405159.png)

![1666442427490](C:\Users\HP\AppData\Local\Temp\1666442427490.png)

![1666442453445](C:\Users\HP\AppData\Local\Temp\1666442453445.png)

![1666442484913](C:\Users\HP\AppData\Local\Temp\1666442484913.png)

这样就成功创建了工程

4、使用keil设置工程

将如下代码设置在main函数中的while循环当中

```c
 char data[]="hello windows!\n";
		HAL_UART_Transmit(&huart2, (uint8_t *)data, 15, 0xffff);
		//高电平点亮A12
		HAL_GPIO_WritePin(GPIOA,GPIO_PIN_12,GPIO_PIN_SET);
		
		HAL_Delay(100);
		//低电平熄灭A12
		HAL_GPIO_WritePin(GPIOA,GPIO_PIN_12,GPIO_PIN_RESET);
		HAL_Delay(900);
```

5、编译并烧录

![1666442617809](C:\Users\HP\AppData\Local\Temp\1666442617809.png)

![1666442666164](C:\Users\HP\AppData\Local\Temp\1666442666164.png)

6、使用野火串口调试助手运行

![1666442726832](C:\Users\HP\AppData\Local\Temp\1666442726832.png)

运行成功

### 4、仿真运行串口通信

1、配置debug的设置如下：

![1666443007697](C:\Users\HP\AppData\Local\Temp\1666443007697.png)

2、开始调试

![1666443043972](C:\Users\HP\AppData\Local\Temp\1666443043972.png)

3、再命令行输入下列语句

```
LA ((((PORTA&0x00000010)>>4&0x10)>>4 & 0x10) >> 4 & 0x10) >> 4
LA (((PORTA&0x00001000)>>12 & 0x1000) >> 12 & 0x1000) >> 12
```

4、运行得到仿真结果

![1666443109222](C:\Users\HP\AppData\Local\Temp\1666443109222.png)



#### 感谢大家的观看，如有不正，还望指出！