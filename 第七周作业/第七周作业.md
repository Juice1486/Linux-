### 1、使用HAL库采用中断模式编程，当开关接高电平时，LED亮灯；接低电平时，LED灭灯。 

（1）引脚配置

```
A4输出控制灯的亮灭,设置为GPIO_Output
A1持续输出高电平,设置同上
A7持续输出低电平,设置同上
B5模拟开关,设置为GPIO_EXTI5
```

![1666524599038](C:\Users\HP\AppData\Local\Temp\1666524599038.png)

（2）配置exit

![1666524675614](C:\Users\HP\AppData\Local\Temp\1666524675614.png)

（3）配置SYS

![1666524707871](C:\Users\HP\AppData\Local\Temp\1666524707871.png)

（4）配置GPIO

```
把A1配置为高电平、A7配置为低电平
把B5中断配置为上升沿和下降沿都触发
```

![1666524751594](C:\Users\HP\AppData\Local\Temp\1666524751594.png)

（5）勾选并创建项目

![1666524785495](C:\Users\HP\AppData\Local\Temp\1666524785495.png)

![1666524794128](C:\Users\HP\AppData\Local\Temp\1666524794128.png)

（6）通过keil打开项目，并找到往下找到HAL_GPIO_EXTI_Callback

该函数是给用户自己重写的，可以在这里根据不同的[中断](https://so.csdn.net/so/search?q=%E4%B8%AD%E6%96%AD&spm=1001.2101.3001.7020)来执行不同的处理。在这里我们需要根据B5的不同中断来实现A4的亮灭。 

使用下面的代码重写该函数

```
    void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin){
      if(GPIO_Pin == SWITCH_Pin){
        //获取B5的电位
        GPIO_PinState pinState = HAL_GPIO_ReadPin(SWITCH_GPIO_Port,SWITCH_Pin);

        //低电位
        if(pinState==GPIO_PIN_RESET)
        HAL_GPIO_WritePin(LED_A4_GPIO_Port,LED_A4_Pin,GPIO_PIN_RESET);//把A4变为低电位
        //高电位
        else
            HAL_GPIO_WritePin(LED_A4_GPIO_Port,LED_A4_Pin,GPIO_PIN_SET);//把A4变为高电位
        }
    }

```

（7）编译生成.hex文件，并且mcuisp进行烧录

![1666524946842](C:\Users\HP\AppData\Local\Temp\1666524946842.png)

（8）结果

### 2、采用串口中断方式进行串口通信

（1）设置RCC

![img](https://img-blog.csdnimg.cn/bb24d5dc1ace42bab5339046d5a323a9.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6YaJ5oSP5Li25Y2D5bGC5qKm,size_20,color_FFFFFF,t_70,g_se,x_16)

(2)设置sys 

## ![在这里插入图片描述](https://img-blog.csdnimg.cn/f6066eeea53141fcaa9f6cf3f407187f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6YaJ5oSP5Li25Y2D5bGC5qKm,size_20,color_FFFFFF,t_70,g_se,x_16)

(3)设置usart

![在这里插入图片描述](https://img-blog.csdnimg.cn/3576b61acdea4e5eab8e6d7c1eb63f2c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6YaJ5oSP5Li25Y2D5bGC5qKm,size_20,color_FFFFFF,t_70,g_se,x_16)

(4)设置NVIC

![在这里插入图片描述](https://img-blog.csdnimg.cn/65a2230f328e4196bf267b4bdd8a4308.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6YaJ5oSP5Li25Y2D5bGC5qKm,size_20,color_FFFFFF,t_70,g_se,x_16)

(5)创建项目

![在这里插入图片描述](https://img-blog.csdnimg.cn/13e82a4f5385460bb26b7e7c49b4d82d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6YaJ5oSP5Li25Y2D5bGC5qKm,size_20,color_FFFFFF,t_70,g_se,x_16)

 （6）再keil中配置项目

再main.c文件中定义全局变量

![1666525462309](C:\Users\HP\AppData\Local\Temp\1666525462309.png)

```c
char c;//指令 0:停止  1:开始
char message[]="hello Windows\n";//输出信息
char tips[]="CommandError\n";//提示1
char tips1[]="Start.....\n";//提示2
char tips2[]="Stop......\n";//提示3
int flag=0;//标志 0:停止发送 1.开始发送
#define COUNTOF(a) (sizeof(a)/sizeof(*(a)))
```

再main.c文件中设置接受中断

函数原型：

```
 HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
```

功能：

```
 功能：串口中断接收，以中断方式接收指定长度数据。
 大致过程是，设置数据存放位置，接收数据长度，然后使能串口接收中断。
 接收到数据时，会触发串口中断。
 再然后，串口中断函数处理，直到接收到指定长度数据
 而后关闭中断，进入中断接收回调函数，不再触发接收中断。(只触发一次中断)
```

```
HAL_UART_Receive_IT(&huart1, (uint8_t *)&c, 1);
```

在main.c函数中的while循环中加入下面的代码：

```c
if(flag==1){
			//发送信息
			HAL_UART_Transmit(&huart1, (uint8_t *)&message, COUNTOF(message),0xFFFF); 
			
			//延时
			HAL_Delay(1000);
		}
```

在main.c文件中重写中断处理函数：

```c
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
	
	//当输入的指令为0时,发送提示并改变flag
	if(c=='s'){
		flag=0;
		HAL_UART_Transmit(&huart1, (uint8_t *)&tips2, COUNTOF(tips2),0xFFFF); 
	}
	
	//当输入的指令为1时,发送提示并改变flag
	else if(c=='t'){
		flag=1;
		HAL_UART_Transmit(&huart1, (uint8_t *)&tips1, COUNTOF(tips1),0xFFFF); 
	}
	
	//当输入不存在指令时,发送提示并改变flag
	else {
	
	}

	//重新设置中断
		HAL_UART_Receive_IT(&huart1, (uint8_t *)&c, 1);  
}
```

（7）编译并进行烧录

![1666525827547](C:\Users\HP\AppData\Local\Temp\1666525827547.png)

(8)使用串口调试工具进行运行

![1666526463382](C:\Users\HP\AppData\Local\Temp\1666526463382.png)

![1666526475099](C:\Users\HP\AppData\Local\Temp\1666526475099.png)

### 3、使用字符串进行中断

找到HAL_UART_RxCpltCallback函数，修改下列内容：

```c
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart1){
	HAL_UART_IRQHandler(huart1);
	getBuffer[countofGetBuffer++]=value;
	if(strcmp(getBuffer,str1)==0){
		flag = 1;
		HAL_UART_Transmit(huart1, (uint8_t *)&tips1, COUNTOF(tips1),0xFFFF);
		countofGetBuffer = 0;
		memset(getBuffer,0,COUNTOF(getBuffer));
	}else if(strcmp(getBuffer,str2)==0){
	    flag = 0;
		HAL_UART_Transmit(huart1, (uint8_t *)&tips2, COUNTOF(tips2),0xFFFF); 
		countofGetBuffer = 0;
		memset(getBuffer,0,COUNTOF(getBuffer));
	}
	HAL_UART_Receive_IT(huart1, (uint8_t *)&value,1);
}
```

当我们执行 HAL_UART_Receive_IT(&huart1, (uint8_t *)&value, 1)这个函数的时候，表示我们接收到一个字符，并且之后将会HAL_UART_RxCpltCallback，所以我们可以使用一个全局变量数组进行，每进行一次运算。就添加一个字符进入数组。当积累到一定值就会进入if语句中。执行语句，从而达到发送字符串接受的效果。

添加一下全局变量：

```c
char getBuffer[100]; //用户自定义的缓冲区
char value;
char str1[] = "gostm32";
char str2[] = "stopstm32";
char message[]="hello Windows\n";//输出信息
char tips[]="CommandError\n";//提示1
char tips1[]="Start.....\n";//提示2
char tips2[]="Stop......\n";//提示3
int flag=0;//标志 0:停止发送 1.开始发送
int countofGetBuffer=0;
```

编译并进行烧录，使用野火串口调试运行

![1666624156272](C:\Users\HP\AppData\Local\Temp\1666624156272.png)

![1666624183879](C:\Users\HP\AppData\Local\Temp\1666624183879.png)

### 4、STM32采用串口DMA方式，用115200bps或更高速率向上位机连续发送数据 

（1)使用sm32cubemx创建项目

设置RCC：

![img](https://img-blog.csdnimg.cn/c84150b6386048b3b591a273af42e5a0.png) 

设置串口USART1,同时可查看波特率等设置是否正确：

![img](https://img-blog.csdnimg.cn/8d489d327f484bfbb10dffd66fecec39.png) 

使能中断选择：

![img](https://img-blog.csdnimg.cn/31de7f35a6974ce892338e2ebb6c9e4b.png) 

DMA设置点击DMA Settings，点击Add添加通道，传输速率设置为中速Medium：

![在这里插入图片描述](https://img-blog.csdnimg.cn/498f0b5f9afe49138bd0a0ae98839e21.png) 

分别点击两个通道，查看模式设置是否为Normal，右侧Memory是否选中：

![在这里插入图片描述](https://img-blog.csdnimg.cn/3f05bc4ab7a54223bc216f577be5651a.png) 

在System view下选择DMA，并ADD通道MEMTOMEM：

![在这里插入图片描述](https://img-blog.csdnimg.cn/573db026d2f44bf2b38e06ad68308109.png) 

时钟设置：

![在这里插入图片描述](https://img-blog.csdnimg.cn/fd83993d4f9442afa487c4fbe883bd22.png) 

工程文件配置
Project配置：

![img](https://img-blog.csdnimg.cn/0db85e9380f44cba9e346bd9c7ef2bb3.png) 

Code Generator配置：

![img](https://img-blog.csdnimg.cn/3983edf0cb9a4e1daea323315cd3c5d5.png) 

Open Project：

![在这里插入图片描述](https://img-blog.csdnimg.cn/8318d75ce3624961ba338694fad9dca9.png) 

（2）Keil环境下进行代码编写：

```c
uint8_t Senbuff[] = "Hello world！";  //定义数据发送数组
```

![img](https://img-blog.csdnimg.cn/44255dce4a8a4c4b84de535673b942da.png) 

在main函数中的while循环里添加：

```
  HAL_UART_Transmit_DMA(&huart1, (uint8_t *)Senbuff, sizeof(Senbuff));
  HAL_Delay(1000);
```

![img](https://img-blog.csdnimg.cn/bdeb217f37a14160ac25a3de41907140.png) 

（3）工作代码进行编译和烧录

![1666625713541](C:\Users\HP\AppData\Local\Temp\1666625713541.png)

（4）运行

![1666625734143](C:\Users\HP\AppData\Local\Temp\1666625734143.png)

